import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

#path of the annotation file (*.csv) generated by MZmine with the "Export all annotations to CSV file" module
annotation_file = pd.read_csv("file_path")

#path of the quantification table (*.csv) generated by MZmine with the "Export molecular networking files" module
quant_file = pd.read_csv("file_path")

#cosine scores and column headers collection in two lists from the annotation file and the quantification table respectively
cosines = annotation_file["score"].tolist()
column_headers = quant_file.columns.tolist()

#creation of the different lists for data handling
filenames = []
reactions = []
areas = []
relative_abundances = []

#append the filenames list with the .mzXML headers related to the .mzXML files processed in MZmine
for header in column_headers:
    extension = ".mzXML"
    if extension in header:
        filenames.append(header)

#associate each filename to its related probe area
for filename in filenames:
    area = quant_file[filename].tolist()
    filename = filename.replace(".mzXML Peak area", "")
    reactions.append(int(filename)) #in this work, filenames correspond to reactions label
    areas.append(max(area)) #the maximum value is equal to zero if no ion sharing the same m/z and RT than probe was found during the MZmine process

#relative abundances calculation
for area in areas:
    area_max = max(areas)
    relative_abundance = (area/area_max)*100
    relative_abundances.append(relative_abundance)

#append a cosine score of zero for reactions where the probe was not detected (relative abundance equal to zero)
cosines_extended = [] #creation of a new list to compile all cosine scores
for value in relative_abundances:
    if value == 0:
        cosines_extended.append(0)
    else:
        cosines_extended.append(cosines.pop(0))

#compilation of the useful data into a data frame
df_data = pd.DataFrame({'reaction':reactions, 'relative abundance':relative_abundances, 'cosine':cosines_extended})
df_data_srt = df_data.sort_values(by='reaction') #sorts the data frame by reaction

#cosine scores extraction from the sorted data frame and filtration with a minimum cosine score of 0.9
cosines_srt = df_data_srt['cosine'].tolist()
cosines_srt_rnd = [round(cosine, 2) for cosine in cosines_srt]
cosines_srt_rnd_filt = [0 if x < 0.9 else x for x in cosines_srt_rnd] #the cosine score threshold can be modified to adjust the level of confidence

#creation of an adapted cosine score array for the cosine score-based heatmap layout
cosines_sublist = [cosines_srt_rnd_filt[i:i+8] for i in range(0, len(cosines_srt_rnd_filt), 8)]
cosines_array = np.array(np.transpose(cosines_sublist))

#relative abundance extraction from the sorted data frame and filtration based on the previous cosine score filtration
relative_abundances_srt = df_data_srt['relative abundance'].tolist()
relative_abundances_srt_rnd = [round(value, 1) for value in relative_abundances_srt]
relative_abundances_srt_rnd_filt = []

for i in range(len(cosines_srt_rnd_filt)):
    if cosines_srt_rnd_filt[i] == 0:
        relative_abundances_srt_rnd_filt.append(0)
    else:
        relative_abundances_srt_rnd_filt.append(relative_abundances_srt_rnd[i])

#creation of an adapted relative abundance array for the relative abundance-based heatmap layout
relative_abundances_sublist = [relative_abundances_srt_rnd_filt[i:i+8] for i in range(0, len(relative_abundances_srt_rnd_filt), 8)]
relative_abundances_array = np.array(np.transpose(relative_abundances_sublist))

#preparation of the labels based on the reaction conditions codification (three parameters have been modified herein)
solv_order = ["1.1/3.1", "1.1/3.2", "1.1/3.3", "1.1/3.4", "1.2/3.1", "1.2/3.2", "1.2/3.3",
                  "1.2/3.4", "1.3/3.1", "1.3/3.2", "1.3/3.3", "1.3/3.4"]
additive = ["2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8"]

#creation of the cosine score-based heatmap
fig, ax = plt.subplots()
im = ax.imshow(cosines_array, cmap='viridis', vmin=0, vmax=1)
ax.set_xticks(np.arange(len(solv_order)), labels=solv_order, size=9.5)
ax.set_yticks(np.arange(len(additive)), labels=additive, size=9.5)
ax.set_ylabel("catalyst (2.x)", size=9.5, weight="bold")
plt.title("solvent (1.x) / reagent addition order (3.x)", size=9.5, weight="bold")
plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")

for i in range(8):
    for j in range(12):
            text = ax.text(j, i, cosines_array[i, j], ha="center", va="center", color="w", size=9.5)

cbar = ax.figure.colorbar(im, ax=ax, shrink=0.665, aspect=15, anchor=(-0.35, 0.5))
cbar.ax.set_ylabel("probe cosine score", rotation=-90, va="bottom", size=9.5) #replace "probe" by the name of the relevant probe
cbar.ax.tick_params(labelsize=9.5)
fig.tight_layout()

#creation of the relative abundance-based heatmap
fig, ax = plt.subplots()
im = ax.imshow(relative_abundances_array, cmap='viridis')
ax.set_xticks(np.arange(len(solv_order)), labels=solv_order, size=9.5)
ax.set_yticks(np.arange(len(additive)), labels=additive, size=9.5)
ax.set_ylabel("catalyst (2.x)", size=9.5, weight="bold")
plt.title("solvent (1.x) / reagent addition order (3.x)", size=9.5, weight="bold")
plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")

for i in range(8):
    for j in range(12):
            text = ax.text(j, i, relative_abundances_array[i, j], ha="center", va="center", color="w", size=9.5)

cbar = ax.figure.colorbar(im, ax=ax, shrink=0.665, aspect=15, anchor=(-0.35, 0.5))
cbar.ax.set_ylabel("probe relative abundance (%)", rotation=-90, va="bottom", size=9.5) #replace "probe" by the name of the relevant probe
cbar.ax.tick_params(labelsize=9.5)
fig.tight_layout()

plt.show()

